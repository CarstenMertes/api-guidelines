# Change Status & Action Request

Microsoft Graph API Design Pattern

_The change status pattern is an effective alternative to model the ability to trigger side effects while keeping an agnostic, data driven approach_

## Problem

In some cases, exposed resources can trigger side effects that modify the system behavior. For instance, a [`riskyUser`](https://docs.microsoft.com/en-us/graph/api/resources/riskyuser?view=graph-rest-1.0) can be [`confirmed`](https://docs.microsoft.com/en-us/graph/api/riskyuser-confirmcompromised?view=graph-rest-1.0&tabs=http) or [`dismissed`](https://docs.microsoft.com/en-us/graph/api/riskyuser-confirmcompromised?view=graph-rest-1.0&tabs=http).

These situation are often modeled as a `POST` request to a specific endpoint in the same URI space of the resource, triggering the side effect directly and not returning any data. While it might be a quick and easy solution, there are some considerations:

- The API should be exposing resources and allow their manipulation, while Actions resemble a remote procedure call on an object, typical of [OOP][1]
- It couples the request with the side effect, making more difficult to test, log, replay and reason about what is happening in the system
- It forces the consumer to follow the [OOP][1] approach at the API level. We do not want to pursue any specific style and the developers writing the client might be working in other ways

## Solution

API Designers can prefer the usage of a `status` property or a datafyed version of the intended action to represent the **intent** of triggering a side effect rather than starting the execution directly through the HTTP request.

Taking in consideration the example of the `riskyUser` above, it is possible to add a `status` property to the resource:

```xml
<EnumType Name="riskyStatus">
    <Member Name="confirmed" Value="0"/>
    <Member Name="dismissed" Value="1"/>
    <Member Name="unknown" Value="2"/>
</EnumType>

<EntityType Name="riskyUser" >
    <Property Name="status" Type="riskyStatus" />
</EntityType>
```

It is now possible to change the status through a PATCH request to the entity:

```bash
curl -X PATCH --json '{"status": "confirmed"}' https://graph.microsoft.com/v1.0/riskyUsers/a57dc75f-24b5-47ce-b5e1-44822f5d4729
```

Instead of returning an empty body with `204` status code, depending on the situation, the response should contain the status of the request, if can be satisfied in a reasonable time:

```json
{
  "newStatus": "confirmed"
}
```

If the response triggers a long running operation, the response should contain a reference to query its status, following the [existing guidance][2]. The status on the resource shall stay the same until the long running operation is completed:

```json
{
  "createdDateTime": "2015-06-19T12-01-03.4Z",
  "status": "disabling"
}
```

---

There might be cases where the change of the status might require some additional parameters, or where we might need to execute an action that is not 100% related to the entity. In such case, a `ChangeStatusRequest` object might be created to accommodate this use case.

For instance, let's say the `riskyUser` confirmation process also requires a parameter that defines for how much time the user is going to be disabled. In this case, instead of a `status` property on the exposed resource, we can define a new resource and create a new instance representing the intention:

```xml
<EnumType Name="riskyStatus">
    <Member Name="confirmed" Value="0"/>
    <Member Name="dismissed" Value="1"/>
    <Member Name="unknown" Value="2"/>
</EnumType>

<EntityType Name="riskAssessment" >
    <Property Name="status" Type="riskyStatus" />
    <Property Name="duration" Type="Edm.Int32" />
</EntityType>
```

```bash
curl --json '{"status": "confirmed", "duration": 3600}' https://graph.microsoft.com/v1.0/riskyUsers/a57dc75f-24b5-47ce-b5e1-44822f5d4729/riskAssessments
```

## Issues and Considerations

The nature of this pattern is to privilege resources and data manipulation rather than taking an opinionated stand. This means that the generated SDK might look slightly different than the rest of the system, especially if autogenerated. On the other hand, it leaves a great degree of freedom to concretize an SDK according to the methodologies provided by the target programming language.

[1]: https://en.wikipedia.org/wiki/Object-oriented_programming
[2]: https://dev.azure.com/msazure/One/_wiki/wikis/Microsoft%20Graph%20Partners/211713/Long-running-operations
